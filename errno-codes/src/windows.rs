// This file is generated automatically. Do not modify it by hand.

// For code generated by `phf_codegen`.
#![cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]

use std;

use phf;

use ErrnoCode;
use ErrnoCodes;

/// Return structure describing error number.
///
/// Returns None on unknown errnum.
///
/// Returns only the first structure if there are multiple error
/// identifiers/messages defined for the same numeric constant.
pub fn info_by_num(errnum: std::os::raw::c_int) -> Option<&'static ErrnoCode> {
    BY_NUM.get(&errnum).map(|infos| &infos[0])
}

/// Return structure describing error identifier.
///
/// Returns None on unknown err_id.
pub fn info_by_id(err_id: &str) -> Option<&'static ErrnoCode> {
    BY_ID.get(err_id)
}

/// Return string describing error number.
///
/// Returns None on unknown errnum.
///
/// Returns only the first message if there are multiple error messages defined
/// for the same numeric constant.
pub fn strerror(errnum: std::os::raw::c_int) -> Option<&'static str> {
    info_by_num(errnum).map(|info| info.msg)
}

/// Operation not permitted.
pub const EPERM: std::os::raw::c_int = 1;
/// Human-readable message for EPERM.
pub const EPERM_MSG: &str = "Operation not permitted";
/// Identifier for EPERM as a string (equals to "EPERM").
pub const EPERM_ID: &str = "EPERM";

/// No such file or directory.
pub const ENOFILE: std::os::raw::c_int = 2;
/// Human-readable message for ENOFILE.
pub const ENOFILE_MSG: &str = "No such file or directory";
/// Identifier for ENOFILE as a string (equals to "ENOFILE").
pub const ENOFILE_ID: &str = "ENOFILE";

/// Same as ENOFILE (No such file or directory).
pub const ENOENT: std::os::raw::c_int = 2;
/// Human-readable message for ENOENT.
pub const ENOENT_MSG: &str = "Same as ENOFILE (No such file or directory)";
/// Identifier for ENOENT as a string (equals to "ENOENT").
pub const ENOENT_ID: &str = "ENOENT";

/// No such process.
pub const ESRCH: std::os::raw::c_int = 3;
/// Human-readable message for ESRCH.
pub const ESRCH_MSG: &str = "No such process";
/// Identifier for ESRCH as a string (equals to "ESRCH").
pub const ESRCH_ID: &str = "ESRCH";

/// Interrupted function call.
pub const EINTR: std::os::raw::c_int = 4;
/// Human-readable message for EINTR.
pub const EINTR_MSG: &str = "Interrupted function call";
/// Identifier for EINTR as a string (equals to "EINTR").
pub const EINTR_ID: &str = "EINTR";

/// Input/output error.
pub const EIO: std::os::raw::c_int = 5;
/// Human-readable message for EIO.
pub const EIO_MSG: &str = "Input/output error";
/// Identifier for EIO as a string (equals to "EIO").
pub const EIO_ID: &str = "EIO";

/// No such device or address.
pub const ENXIO: std::os::raw::c_int = 6;
/// Human-readable message for ENXIO.
pub const ENXIO_MSG: &str = "No such device or address";
/// Identifier for ENXIO as a string (equals to "ENXIO").
pub const ENXIO_ID: &str = "ENXIO";

/// Arg list too long.
pub const E2BIG: std::os::raw::c_int = 7;
/// Human-readable message for E2BIG.
pub const E2BIG_MSG: &str = "Arg list too long";
/// Identifier for E2BIG as a string (equals to "E2BIG").
pub const E2BIG_ID: &str = "E2BIG";

/// Exec format error.
pub const ENOEXEC: std::os::raw::c_int = 8;
/// Human-readable message for ENOEXEC.
pub const ENOEXEC_MSG: &str = "Exec format error";
/// Identifier for ENOEXEC as a string (equals to "ENOEXEC").
pub const ENOEXEC_ID: &str = "ENOEXEC";

/// Bad file descriptor.
pub const EBADF: std::os::raw::c_int = 9;
/// Human-readable message for EBADF.
pub const EBADF_MSG: &str = "Bad file descriptor";
/// Identifier for EBADF as a string (equals to "EBADF").
pub const EBADF_ID: &str = "EBADF";

/// No child processes.
pub const ECHILD: std::os::raw::c_int = 10;
/// Human-readable message for ECHILD.
pub const ECHILD_MSG: &str = "No child processes";
/// Identifier for ECHILD as a string (equals to "ECHILD").
pub const ECHILD_ID: &str = "ECHILD";

/// Resource temporarily unavailable.
pub const EAGAIN: std::os::raw::c_int = 11;
/// Human-readable message for EAGAIN.
pub const EAGAIN_MSG: &str = "Resource temporarily unavailable";
/// Identifier for EAGAIN as a string (equals to "EAGAIN").
pub const EAGAIN_ID: &str = "EAGAIN";

/// Not enough space.
pub const ENOMEM: std::os::raw::c_int = 12;
/// Human-readable message for ENOMEM.
pub const ENOMEM_MSG: &str = "Not enough space";
/// Identifier for ENOMEM as a string (equals to "ENOMEM").
pub const ENOMEM_ID: &str = "ENOMEM";

/// Permission denied.
pub const EACCES: std::os::raw::c_int = 13;
/// Human-readable message for EACCES.
pub const EACCES_MSG: &str = "Permission denied";
/// Identifier for EACCES as a string (equals to "EACCES").
pub const EACCES_ID: &str = "EACCES";

/// Bad address.
pub const EFAULT: std::os::raw::c_int = 14;
/// Human-readable message for EFAULT.
pub const EFAULT_MSG: &str = "Bad address";
/// Identifier for EFAULT as a string (equals to "EFAULT").
pub const EFAULT_ID: &str = "EFAULT";

/// strerror reports \"Resource device\".
pub const EBUSY: std::os::raw::c_int = 16;
/// Human-readable message for EBUSY.
pub const EBUSY_MSG: &str = "strerror reports \"Resource device\"";
/// Identifier for EBUSY as a string (equals to "EBUSY").
pub const EBUSY_ID: &str = "EBUSY";

/// File exists.
pub const EEXIST: std::os::raw::c_int = 17;
/// Human-readable message for EEXIST.
pub const EEXIST_MSG: &str = "File exists";
/// Identifier for EEXIST as a string (equals to "EEXIST").
pub const EEXIST_ID: &str = "EEXIST";

/// Improper link (cross-device link?).
pub const EXDEV: std::os::raw::c_int = 18;
/// Human-readable message for EXDEV.
pub const EXDEV_MSG: &str = "Improper link (cross-device link?)";
/// Identifier for EXDEV as a string (equals to "EXDEV").
pub const EXDEV_ID: &str = "EXDEV";

/// No such device.
pub const ENODEV: std::os::raw::c_int = 19;
/// Human-readable message for ENODEV.
pub const ENODEV_MSG: &str = "No such device";
/// Identifier for ENODEV as a string (equals to "ENODEV").
pub const ENODEV_ID: &str = "ENODEV";

/// Not a directory.
pub const ENOTDIR: std::os::raw::c_int = 20;
/// Human-readable message for ENOTDIR.
pub const ENOTDIR_MSG: &str = "Not a directory";
/// Identifier for ENOTDIR as a string (equals to "ENOTDIR").
pub const ENOTDIR_ID: &str = "ENOTDIR";

/// Is a directory.
pub const EISDIR: std::os::raw::c_int = 21;
/// Human-readable message for EISDIR.
pub const EISDIR_MSG: &str = "Is a directory";
/// Identifier for EISDIR as a string (equals to "EISDIR").
pub const EISDIR_ID: &str = "EISDIR";

/// Invalid argument.
pub const EINVAL: std::os::raw::c_int = 22;
/// Human-readable message for EINVAL.
pub const EINVAL_MSG: &str = "Invalid argument";
/// Identifier for EINVAL as a string (equals to "EINVAL").
pub const EINVAL_ID: &str = "EINVAL";

/// Too many open files in system.
pub const ENFILE: std::os::raw::c_int = 23;
/// Human-readable message for ENFILE.
pub const ENFILE_MSG: &str = "Too many open files in system";
/// Identifier for ENFILE as a string (equals to "ENFILE").
pub const ENFILE_ID: &str = "ENFILE";

/// Too many open files.
pub const EMFILE: std::os::raw::c_int = 24;
/// Human-readable message for EMFILE.
pub const EMFILE_MSG: &str = "Too many open files";
/// Identifier for EMFILE as a string (equals to "EMFILE").
pub const EMFILE_ID: &str = "EMFILE";

/// Inappropriate I/O control operation.
pub const ENOTTY: std::os::raw::c_int = 25;
/// Human-readable message for ENOTTY.
pub const ENOTTY_MSG: &str = "Inappropriate I/O control operation";
/// Identifier for ENOTTY as a string (equals to "ENOTTY").
pub const ENOTTY_ID: &str = "ENOTTY";

/// File too large.
pub const EFBIG: std::os::raw::c_int = 27;
/// Human-readable message for EFBIG.
pub const EFBIG_MSG: &str = "File too large";
/// Identifier for EFBIG as a string (equals to "EFBIG").
pub const EFBIG_ID: &str = "EFBIG";

/// No space left on device.
pub const ENOSPC: std::os::raw::c_int = 28;
/// Human-readable message for ENOSPC.
pub const ENOSPC_MSG: &str = "No space left on device";
/// Identifier for ENOSPC as a string (equals to "ENOSPC").
pub const ENOSPC_ID: &str = "ENOSPC";

/// Invalid seek (seek on a pipe?).
pub const ESPIPE: std::os::raw::c_int = 29;
/// Human-readable message for ESPIPE.
pub const ESPIPE_MSG: &str = "Invalid seek (seek on a pipe?)";
/// Identifier for ESPIPE as a string (equals to "ESPIPE").
pub const ESPIPE_ID: &str = "ESPIPE";

/// Read-only file system.
pub const EROFS: std::os::raw::c_int = 30;
/// Human-readable message for EROFS.
pub const EROFS_MSG: &str = "Read-only file system";
/// Identifier for EROFS as a string (equals to "EROFS").
pub const EROFS_ID: &str = "EROFS";

/// Too many links.
pub const EMLINK: std::os::raw::c_int = 31;
/// Human-readable message for EMLINK.
pub const EMLINK_MSG: &str = "Too many links";
/// Identifier for EMLINK as a string (equals to "EMLINK").
pub const EMLINK_ID: &str = "EMLINK";

/// Broken pipe.
pub const EPIPE: std::os::raw::c_int = 32;
/// Human-readable message for EPIPE.
pub const EPIPE_MSG: &str = "Broken pipe";
/// Identifier for EPIPE as a string (equals to "EPIPE").
pub const EPIPE_ID: &str = "EPIPE";

/// Domain error (math functions).
pub const EDOM: std::os::raw::c_int = 33;
/// Human-readable message for EDOM.
pub const EDOM_MSG: &str = "Domain error (math functions)";
/// Identifier for EDOM as a string (equals to "EDOM").
pub const EDOM_ID: &str = "EDOM";

/// Result too large (possibly too small).
pub const ERANGE: std::os::raw::c_int = 34;
/// Human-readable message for ERANGE.
pub const ERANGE_MSG: &str = "Result too large (possibly too small)";
/// Identifier for ERANGE as a string (equals to "ERANGE").
pub const ERANGE_ID: &str = "ERANGE";

/// Resource deadlock avoided (non-Cyg).
pub const EDEADLOCK: std::os::raw::c_int = 36;
/// Human-readable message for EDEADLOCK.
pub const EDEADLOCK_MSG: &str = "Resource deadlock avoided (non-Cyg)";
/// Identifier for EDEADLOCK as a string (equals to "EDEADLOCK").
pub const EDEADLOCK_ID: &str = "EDEADLOCK";

/// Same as EDEADLOCK (Resource deadlock avoided (non-Cyg)).
pub const EDEADLK: std::os::raw::c_int = 36;
/// Human-readable message for EDEADLK.
pub const EDEADLK_MSG: &str = "Same as EDEADLOCK (Resource deadlock avoided (non-Cyg))";
/// Identifier for EDEADLK as a string (equals to "EDEADLK").
pub const EDEADLK_ID: &str = "EDEADLK";

/// Filename too long (91 in Cyg?).
pub const ENAMETOOLONG: std::os::raw::c_int = 38;
/// Human-readable message for ENAMETOOLONG.
pub const ENAMETOOLONG_MSG: &str = "Filename too long (91 in Cyg?)";
/// Identifier for ENAMETOOLONG as a string (equals to "ENAMETOOLONG").
pub const ENAMETOOLONG_ID: &str = "ENAMETOOLONG";

/// No locks available (46 in Cyg?).
pub const ENOLCK: std::os::raw::c_int = 39;
/// Human-readable message for ENOLCK.
pub const ENOLCK_MSG: &str = "No locks available (46 in Cyg?)";
/// Identifier for ENOLCK as a string (equals to "ENOLCK").
pub const ENOLCK_ID: &str = "ENOLCK";

/// Function not implemented (88 in Cyg?).
pub const ENOSYS: std::os::raw::c_int = 40;
/// Human-readable message for ENOSYS.
pub const ENOSYS_MSG: &str = "Function not implemented (88 in Cyg?)";
/// Identifier for ENOSYS as a string (equals to "ENOSYS").
pub const ENOSYS_ID: &str = "ENOSYS";

/// Directory not empty (90 in Cyg?).
pub const ENOTEMPTY: std::os::raw::c_int = 41;
/// Human-readable message for ENOTEMPTY.
pub const ENOTEMPTY_MSG: &str = "Directory not empty (90 in Cyg?)";
/// Identifier for ENOTEMPTY as a string (equals to "ENOTEMPTY").
pub const ENOTEMPTY_ID: &str = "ENOTEMPTY";

/// Illegal byte sequence.
pub const EILSEQ: std::os::raw::c_int = 42;
/// Human-readable message for EILSEQ.
pub const EILSEQ_MSG: &str = "Illegal byte sequence";
/// Identifier for EILSEQ as a string (equals to "EILSEQ").
pub const EILSEQ_ID: &str = "EILSEQ";

include!(concat!(env!("OUT_DIR"), "/windows.rs"));

#[cfg(test)]
mod tests {
    use ErrnoCode;

    #[test]
    fn info_by_num() {
        assert_eq!(
            super::info_by_num(super::EDOM),
            Some(&ErrnoCode {
                num: super::EDOM,
                msg: super::EDOM_MSG,
                id: super::EDOM_ID,
            })
        );
    }

    #[test]
    fn info_by_id() {
        assert_eq!(
            super::info_by_id(super::EDOM_ID),
            Some(&ErrnoCode {
                num: super::EDOM,
                msg: super::EDOM_MSG,
                id: super::EDOM_ID,
            })
        );
    }

    #[test]
    fn strerror() {
        assert_eq!(super::strerror(super::EDOM), Some(super::EDOM_MSG));
        assert_eq!(super::strerror(0), None);
    }
}
